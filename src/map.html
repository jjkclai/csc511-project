<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <link rel="stylesheet" type="text/css" href="./assets/css/map.css">
</head>
<body>
    <div style="float: left">
        <div id="map-svg-container" class="svg-container">
            <div id="map-svg-tooltip" class="tooltip" style="opacity:0"></div>
            <svg id="map-svg" class="svg"></svg>
        </div>

        <div id="time-svg-container" class="svg-container">
            <div id="time-svg-tooltip" class="tooltip" style="opacity:0"></div>
            <svg id="time-svg" class="svg"></svg>
        </div>
    </div>

    <div style="float:right">
        <div id="query-system-container">
            <input type="text" id="query-textbox" class="textbox">
            <input type="button" id="query-submit-button" class="button" value="Submit">
        </div>

        <div id="map-options-container" class="options-container">
            <input type="checkbox" id="grid-checkbox-b" class="checkbox"><label>Show Blue-side Grid</label>
            <input type="checkbox" id="grid-checkbox-r" class="checkbox"><label>Show Red-side Grid</label>
        <div>
    </div>

<script>
    const matchObjectOnOpacity = 0.9;
    const matchObjectOffOpacity = 0.3;
    const playerObjectOnOpacity = 0.9;
    const playerObjectOffOpacity = 0.4;
    const tooltipObjectOnOpacity = 0.9;
    const tooltipObjectOffOpacity = 0;

    d3.csv("https://raw.githubusercontent.com/jkclai/csc511-project/master/src/assets/csv/2019-worlds.csv").then(function(rows) {
        window.data=rows;

        visualizeTime(data);
    });

    window.mapSvg = d3.select("svg#map-svg");
    window.timeSvg = d3.select("svg#time-svg");
    window.mapSvgTooltip = d3.select("div#map-svg-tooltip");
    window.timeSvgTooltip = d3.select("div#time-svg-tooltip");

    mapSvg.append("image")
        .attr("xlink:href", "./assets/images/minimap.png")
        .attr("width", "100%")
        .attr("height", "100%");
    
    d3.select("input#query-submit-button").on("click", function() {
        const query = document.getElementById("query-textbox").value;
        parseQuery(query);
    });

    function parseQuery(query) {
        let infix = tokenizer(query);
        let postfix = parser(infix);
        let indices = calculator(postfix);
        let result = retriever(indices);
        
        unVisualize();
        visualizeTime(result);
    }

    function tokenizer(str) {
        function isOperand(ch) {
            return /\d|\w|\:/.test(ch);
        }
        function isOperatorSingle(ch) {
            return /\!/.test(ch);
        }
        function isOperatorDouble(ch) {
            return /\&|\|/.test(ch);
        }
        function isParenthesisLeft(ch) {
            return (ch === "(");
        }
        function isParenthesisRight(ch) {
            return (ch === ")");
        }

        let result = [];
        let buffer = "";
        let lastType = "";
        let currType = "";

        const strArray = str.replace(/\s+/g, "").split("");
        for(let ch of strArray) {
            if(isOperand(ch)) {
                currType = "operand";
            }
            else if(isOperatorSingle(ch)) {
                currType = "operatorSingle";
            }
            else if(isOperatorDouble(ch)) {
                currType = "operatorDouble";
            }
            else if(isParenthesisLeft(ch)) {
                currType = "parenthesisLeft";
            }
            else if(isParenthesisRight(ch)) {
                currType = "parenthesisRight";
            }

            if(currType.includes("parenthesis")) {
                if(lastType != "") {
                    result.push({
                        name: buffer,
                        type: lastType
                    });
                }

                result.push({
                    name: ch,
                    type: currType
                });

                buffer = "";
                lastType = "";
                continue;
            }

            if(currType == lastType || lastType == "") {
                buffer += ch;
                lastType = currType;
            }
            else if(currType != lastType){
                result.push({
                    name: buffer,
                    type: lastType
                });

                buffer = ch;
                lastType = currType;
            }
        };

        if(lastType != "") {
            result.push({
                name: buffer,
                type: lastType
            });
        }

        return result;
    }

    function parser(tokens) {
        const associativity = {
            "!": "right",
            "&&" : "left",
            "||" : "left"
        };
        const precedence = {
            "!": "3",
            "&&": "2",
            "||": "1"
        };

        let result = [];
        let opStack = [];

        for(let token of tokens) {
            if(token["type"] == "operand") {
                result.push(token);
                continue;
            }
            else if(token["type"].includes("operator")) {
                while(opStack.length > 0) {
                    let op = opStack.slice(-1)[0];
                    if((associativity[token["name"]] == "left" && precedence[token["name"]] <= precedence[op["name"]]) || (associativity[token["name"]] == "right" && precedence[token["name"]] < precedence[op["name"]])) {
                        result.push(opStack.pop());
                    }
                    else {
                        break;
                    }
                }
                opStack.push(token);
            }
            else if(token["type"] == "parenthesisLeft") {
                opStack.push(token);
            }
            else if(token["type"] == "parenthesisRight") {
                while(opStack.slice(-1)[0]["type"] != "parenthesisLeft") {
                    result.push(opStack.pop());
                }
                opStack.pop();
            }
        }

        while(opStack.length != 0) {
            result.push(opStack.pop());
        }

        return result;
    }

    function calculator(tokens) {
        function read(token) {
            let target = token["name"].split(":");

            return window.data.map(function(d) {
                if(d[target[0]].toLowerCase().includes(target[1].toLowerCase())) {
                    return true;
                }
                return false;
            });
        }

        function calculateSingle(operand, operator) {
            if(operator["name"] == "!") {
                return operand.map(function(d) {
                    return !d;
                });
            }
        }

        function calculateDouble(operandA, operandB, operator) {
            if(operator["name"] == "&&") {
                return operandA.map(function(d, i) {
                    return d && operandB[i];
                });
            }
            else if(operator["name"] == "||") {
                return operandA.map(function(d, i) {
                    return d || operandB[i];
                });
            }
        }

        let result = [];

        for(let token of tokens) {
            if(token["type"] == "operand") {
                result.push(read(token));
            }
            else if(token["type"] == "operatorSingle") {
                let operand = result.pop();
                result.push(calculateSingle(operand, token));
            }
            else if(token["type"] == "operatorDouble") {
                let operandB = result.pop();
                let operandA = result.pop();
                result.push(calculateDouble(operandA, operandB, token));
            }
        }
        
        return result[0];
    }

    function retriever(indices) {
        let matches = window.data.filter((d, i) => indices[i]);

        let gameidList = matches.map(d => d["gameid"]);

        return window.data.filter(function(d) {
            return gameidList.includes(d["gameid"]);
        });
    }

    function loadData(targetId, isTeam, isPlayer) {
        const target = window.data.filter(d => d["gameid"] == targetId);

        if(isTeam == 1) {
            visualizeTeam(target);
        }

        if(isPlayer == 1) {
            visualizePlayer(target);
        }
    }

    function unloadData(targetId) {
        mapSvg.selectAll(".team-object").filter("._" + targetId).remove();
        mapSvg.selectAll(".player-object").filter("._" + targetId).remove();
    }

    function unVisualize() {
        mapSvg.selectAll("*").remove();
        timeSvg.selectAll("*").remove();

        mapSvg.append("image")
            .attr("xlink:href", "./assets/images/minimap.png")
            .attr("width", "100%")
            .attr("height", "100%");
    }

    function visualizeTeam(data) {
        const blueTeam = data.filter(d => d["side"] == "Blue");
        const redTeam = data.filter(d => d["side"] == "Red");

        mapSvg.append("text")
            .attr("id", blueTeam[0]["gameid"] + "-" + "blue")
            .attr("class", "team-text heavy-font team-object _" + blueTeam[0]["gameid"])
            .attr("x", "15%")
            .attr("y", "85%")
            .attr("fill", "blue")
            .attr("dominant-baseline", "middle")
            .attr("text-anchor", "middle")
            .text(blueTeam[0]["team"]);
        
        mapSvg.append("text")
            .attr("id", redTeam[0]["gameid"] + "-" + "red")
            .attr("class", "team-text heavy-font team-object _" + redTeam[0]["gameid"])
            .attr("x", "85%")
            .attr("y", "15%")
            .attr("fill", "red")
            .attr("dominant-baseline", "middle")
            .attr("text-anchor", "middle")
            .text(redTeam[0]["team"]);
    }

    function visualizePlayer(data) {
        const blueTeam = data.filter(d => d["playerid"] == 100);
        const redTeam = data.filter(d => d["playerid"] == 200);
        const players = data.filter(d => d["playerid"] <= 10);

        players.sort(function(a, b) {
            if(a["totalgold"] > b["totalgold"]) {
                return 1;
            }
            else if(a["totalgold"] < b["totalgold"]) {
                return -1;
            }
            return 0;
        });

        mapSvg.append("g")
            .selectAll("circle")
            .data(players)
            .enter()
            .append("circle")
                .attr("id", function(d) {
                    return d["gameid"] + "-" + d["side"].toLowerCase() + "-" + d["position"].toLowerCase();
                })
                .attr("class", function(d) {
                    return "player-object _" + d["gameid"];
                })
                .style("opacity", playerObjectOffOpacity)
                .style("stroke", "black")
                .style("fill", function(d) {
                    return d["side"];
                })
                .attr("cx", function(d) {
                    return getIconPos(d)[0] + "%";
                })
                .attr("cy", function(d) {
                    return (100 - getIconPos(d)[1]) + "%";
                })
                .attr("r", function(d) {
                    return getIconRad(d, blueTeam, redTeam) + "%";
                })
                .on("mouseover", playerMouseOver)
                .on("mousemove", playerMouseMove)
                .on("mouseout", playerMouseOut);
    }

    function playerMouseOver(d, i) {
        mapSvg.selectAll("circle")
            .select(function(c) {
                return c === d ? this : null;
            })
            .transition()
            .duration(100)
            .style("opacity", playerObjectOnOpacity);
        
        timeSvg.selectAll(".match-object").filter("._" + d["gameid"])
            .transition()
            .duration(100)
            .style("opacity", matchObjectOnOpacity)
            .style("fill", "black");

        mapSvgTooltip.transition()
            .duration(200)
            .style("opacity", tooltipObjectOnOpacity);
        
        mapSvgTooltip.html(
            "<img class='tooltip-image' src='" + "./assets/images/" + d["champion"] + "Square.png" + "'>" +
            "<div class='tooltip-text'>" +
                "<table>" +
                    "<tr>" +
                        "<th>Team</th>" +
                        "<td>" + d["team"] + "</td>" +
                    "</tr>" +
                    "<tr>" +
                        "<th>Player</th>" +
                        "<td>" + d["player"] + "</td>" +
                    "</tr>" +
                    "<tr>" +
                        "<th>KDA</th>" +
                        "<td>" + d["k"] + "/" + d["d"] + "/" + d["a"] + "</td>" +
                    "</tr>" +
                    "<tr>" +
                        "<th>Gold</th>" +
                        "<td>" + d["totalgold"] + "</td>" +
                    "</tr>" +
                "</table>" +
            "</div>"
        );
    }

    function playerMouseMove(d, i) {
        mapSvgTooltip.style("top", (event.pageY-10)+"px")
            .style("left",(event.pageX+10)+"px");
    }

    function playerMouseOut(d, i) {
        mapSvg.selectAll("circle")
            .select(function(c) {
                return c === d ? this : null;
            })
            .transition()
            .duration(100)
            .style("opacity", playerObjectOffOpacity);
        
        timeSvg.selectAll(".match-object").filter("._" + d["gameid"])
            .transition()
            .duration(100)
            .style("opacity", matchObjectOnOpacity)
            .style("fill", function(d) {
                if(d["result"] == "1") {
                    return "blue";
                }
                else {
                    return "red";
                }
            });

        mapSvgTooltip.transition()
            .duration(200)
            .style("opacity", tooltipObjectOffOpacity);
    }

    function getIconPos(player) {
        function getBase(side) {
            if(side == "Blue") {
                return 50;
            }
            return 50;
        }

        function getDirection(side) {
            if(side == "Blue") {
                return 1;
            }
            return -1;
        }

        function getOffset(k, d, a) {
            return 2 * k + (-2) * d + 1 * a;
        }

        const offset = getDirection(player["side"]) * getOffset(player["k"], player["d"], player["a"]);
        
        const p1 = offset > 0 ? 100 : 0;

        const targetP2 = [14, 32, 50, 68, 86];
        const p2 = targetP2[(player["playerid"] - 1) % 5];

        const p = getBase(player["side"]) + offset;

        return getIntersection([[p1, p1], [p2, (100 - p2)]], [[0, 2 * p], [2 * p, 0]]);
    }

    function getIconRad(player, blueTeam, redTeam) {
        const pGold = player["totalgold"] - 0;
        const bGold = blueTeam[0]["totalgold"] - 0;
        const rGold = redTeam[0]["totalgold"] - 0;

        return 20 * (pGold / (bGold + rGold));
    }

    function getIntersection(lineA, lineB) {
        xDiff = [(lineA[0][0] - lineA[1][0]), (lineB[0][0] - lineB[1][0])];
        yDiff = [(lineA[0][1] - lineA[1][1]), (lineB[0][1] - lineB[1][1])];

        function det(a, b) {
            return a[0] * b[1] - a[1] * b[0];
        }

        div = det(xDiff, yDiff);

        d = [det(lineA[0], lineA[1]), det(lineB[0], lineB[1])];
        x = det(d, xDiff) / div;
        y = det(d, yDiff) / div;

        return [x, y];
    }

    function visualizeTime(data) {
        const schedule = data.filter(d => d["playerid"] == "1").map(function(d) {
            const newData = {};
            newData["gameid"] = d["gameid"];
            newData["result"] = d["result"];
            newData["datetime"] = convertExcelDateToJSDateTime(d["date"], 6);
            newData["date"] = new Date(newData["datetime"].toDateString());

            return newData;
        });

        schedule.sort(function(a, b) {
            if(a["datetime"] > b["datetime"]) {
                return 1;
            }
            else if(a["datetime"] < b["datetime"]) {
                return -1;
            }
            return 0;
        });

        scheduleHash = {};
        schedule.forEach(function(d) {
            if(d["date"] in scheduleHash) {
                scheduleHash[d["date"]]++;
            }
            else {
                scheduleHash[d["date"]] = 1;
            }

            d["count"] = scheduleHash[d["date"]];
        });
        
        const width = timeSvg.style("width").replace("px", "");
        const height = timeSvg.style("height").replace("px", "");
        const margin = width * 0.05;

        const xScale = d3.scaleTime()
            .domain(d3.extent(schedule, function(d) {
                return d["date"];
            }))
            .range([margin, width - margin]);
        const yScale = d3.scaleLinear()
            .domain([0, d3.max(schedule, function(d) {
                return d["count"];
            })])
            .range([height - margin, margin]);
        
        const xAxis = d3.axisBottom(xScale).tickFormat(d3.timeFormat("%Y-%m-%d"));
        const yAxis = d3.axisLeft(yScale);

        const radius = (yScale(0) - yScale(1)) / 2;

        timeSvg.append("g")
            .call(xAxis)
            .attr("transform", "translate(0, " + (height - margin) + ")");

        timeSvg.append("g")
            .call(yAxis)
            .attr("transform", "translate(" + margin + ", 0)");
        
        timeSvg.append("g")
            .selectAll("circle")
            .data(schedule)
            .enter()
            .append("circle")
                .attr("id", function(d) {
                    return d["gameid"];
                })
                .attr("class", function(d) {
                    return "match-object _" + d["gameid"];
                })
                .style("opacity", matchObjectOffOpacity)
                .style("stroke", "black")
                .style("fill", function(d) {
                    if(d["result"] == "1") {
                        return "blue";
                    }
                    else {
                        return "red";
                    }
                })
                .attr("cx", d => xScale(d["date"]) + radius)
                .attr("cy", d => yScale(d["count"]) + radius)
                .attr("r", radius)
                .on("mouseover", matchMouseOver)
                .on("mousemove", matchMouseMove)
                .on("mouseout", matchMouseOut)
                .on("click", matchClick);
    }

    function matchMouseOver(d, i) {
        timeSvg.selectAll("circle")
            .select(function(c) {
                return c === d ? this : null;
            })
            .transition()
            .duration(100)
            .style("opacity", matchObjectOnOpacity)
            .style("fill", "black");
            
        
        loadData(d["gameid"], 1, 1);

        mapSvg.selectAll(".player-object").filter("._" + d["gameid"])
            .transition()
            .duration(100)
            .style("opacity", playerObjectOnOpacity);

        timeSvgTooltip.transition()
            .duration(200)
            .style("opacity", tooltipObjectOnOpacity);
        
        timeSvgTooltip.html(
            "<div class='tooltip-text'>" +
                "<table>" +
                    "<tr>" +
                        "<th>Game ID</th>" +
                        "<td>" + d["gameid"] + "</td>" +
                    "</tr>" +
                    "<tr>" +
                        "<th>Date</th>" +
                        "<td>" + d["date"].toDateString() + "</td>" +
                    "</tr>" +
                "</table>" +
            "</div>"
        );
    }

    function matchMouseMove(d, i) {
        timeSvgTooltip.style("top", (event.pageY-10)+"px")
            .style("left",(event.pageX+10)+"px");
    }

    function matchMouseOut(d, i) {
        const target = timeSvg.selectAll("circle")
            .select(function(c) {
                return c === d ? this : null;
            })
        
        if(target.attr("class").includes("on")) {
            target.transition()
            .duration(100)
            .style("fill", function(d) {
                if(d["result"] == "1") {
                    return "blue";
                }
                else {
                    return "red";
                }
            });

            unloadData(d["gameid"]);
            loadData(d["gameid"], 0, 1)
        }
        else {
            target.transition()
            .duration(100)
            .style("opacity", matchObjectOffOpacity)
            .style("fill", function(d) {
                if(d["result"] == "1") {
                    return "blue";
                }
                else {
                    return "red";
                }
            });

            unloadData(d["gameid"]);
        }

        mapSvg.selectAll(".player-object").filter("._" + d["gameid"])
            .transition()
            .duration(100)
            .style("opacity", playerObjectOffOpacity);
        
        timeSvgTooltip.transition()
            .duration(200)
            .style("opacity", tooltipObjectOffOpacity);
    }

    function matchClick(d, i) {
        const target = timeSvg.selectAll("circle")
            .select(function(c) {
                return c === d ? this : null;
            })
        
        if(target.attr("class").includes("on")) {
            target.attr("class", target.attr("class").replace(" on", ""));
        }
        else {
            target.attr("class", target.attr("class") + " on");
        }
    }

    function convertExcelDateToJSDateTime(excelDate, offset) {
        return new Date(Math.round((excelDate - 25569) * 86400 * 1000) + offset * 60 * 60 * 1000);
    }

    d3.select("input#grid-checkbox-b").on("change", function() {
        gridUpdate("b");
    });
    d3.select("input#grid-checkbox-r").on("change", function() {
        gridUpdate("r");
    });

    function gridUpdate(side) {
        if(d3.select("input#grid-checkbox-" + side).property("checked")){
            showGrid(side);
        } else {
            hideGrid(side);
        }
    }

    function showGrid(side) {
        const targetP1 = ["14%", "32%", "50%", "68%", "86%"];
        const targetX2 = (side == "b") ? "0%" : "100%";
        const targetY2 = (side == "b") ? "100%" : "0%";

        targetP1.forEach(function(item, index) {
            mapSvg.append("line")
                .attr("class", "map-grid-" + side + " dashed-line")
                .attr("x1", item)
                .attr("y1", item)
                .attr("x2", targetX2)
                .attr("y2", targetY2)
                .attr("stroke-width", 5)
                .attr("stroke", "white");
        });
    }
    
    function hideGrid(side) {
        d3.selectAll("line.map-grid-" + side).remove();
    }
</script>
</body>
</html>